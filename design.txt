design.txt
Design document as described in the writeup

The goal was to implement a simple-chess game for local play. This involves several problems, such as determining legal moves, check, checkmate, and draws. In doing this, I used a similar approach to our previous game implementations - I allow moves to be made and then evaluate the board state, and if it is illegal, it is undone and the user is told they must make a different move. Because of this design, I have to consider if a piece is being captured and how to replace it is it is captured in an illegal move. My general idea was to store this 'piece' for later use in case it was needed (this is movePiece and undoMove). The check at the end of turn evaluates if a move is legal, if the kings are in check, it has to evaluate for checkmate. In order to not loop through the entire board, I store the pieces for each player in separate lists (along with conditions for if they have moved, if they were captured, and other important features). These functions describe the core of the game.

For the pieces, I designed a general piece class with subclasses for each specific piece - the subclasses contain movement constraints and piece spcifc mechanics (castling, promotion) while the general piece class has things such as location and player (color). This combined with the basic move and evaluation function is the basic gameplay.

The other functions are in place for drawing the board and generating the ui. In seeing similar products, I found that I liked piece animations, an manual undo move, a last move feature, and when the legal moves for a piece were displayed. I took these particular features and adapted them to the capabilites of Tkinter for bring what is, in my opinion, the best of the experiences of different programs and putting them together to make a good experience within python. I realized that these features I saw as positive influenced when I had negative thoughts related to a program I had found. Thus, my mission was simple - I focused on the positives, because that way I know I am designing something that will contain what is "good" (relative to my standards).

My biggest disappointment was the AI. I could not get it to work in spite of spending countless hours (I'd estimate at least 20+) trying to get it to work, only to get close and then fall behind again. I sought to implement minimax first, but I realized that was slow and tried to improve on it by using alpha-beta pruning. However, I could not get this to work still (the file for it is still in the directory for my project, although it can not be accessed from the main run file). I knew it would be a hard problem, and went in with the expectation that I may fail, but I was really hoping I could at least get something better then random moves. I actually do believe the alpha-beta function was right, but I had a lot of problems with the checkmate/check evaluation that I had to fix (as the time crunch started to kick in). I'm glad I did it though, because it definitely helped me debug and strengthen my program. And, even though I failed to implement the AI correctly, I'm still glad I learned about the evaluation algorithms and understood how they work on some level.